<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Farmunation</title>
        <link rel="icon" type="image/x-icon" href="/Icon.png" />
        <style>
            @import url("https://fonts.googleapis.com/css2?family=Barlow&family=IBM+Plex+Mono&display=swap");

            html {
                font-family: "Barlow", sans-serif;
            }

            .body {
                --bg: #f2f2f2;
                display: flex;
                height: 100vh;
                flex-direction: column;
                margin: 0;
                background-color: var(--bg);
            }

            .b {
                --lnk: #465e73;
                color: var(--lnk);
                font-weight: 800;
            }

            div {
                width: 49%;
                margin-left: auto;
                margin-right: auto;
            }

            ul {
                display: flex;
                margin: auto;
                margin-block-start: 1em;
                margin-block-end: 1em;
                margin-inline-start: 0px;
                margin-inline-end: 0px;
                flex-wrap: wrap;
                justify-content: space-between;
                padding: 0;
            }

            #main-renderer {
                font-family: "IBM Plex Mono";
                padding: 20px 0px;
                font-size: 30px;
                margin: auto;
                width: 90%;
                text-align: center;
                line-height: 1.15;
            }

            .sesame-seeds {
                --headers: #00010d;
                color: var(--headers);
                margin-bottom: 1;
            }

            .theme {
                --bc: #a8b5bf;
                border-style: hidden;
                background-color: var(--bc);
                border-radius: 5px;
                padding: 15px;
            }

            .theme:active {
                --hghltd: #728ca3;
                background-color: var(--hghltd);
            }

            .fluff {
                --text: #00010d;
                color: var(--text);
            }

            #footer {
                position: absolute;
                bottom: 0;
            }
            #bottom-bun {
                margin-top: auto;
            }
            canvas {
                background-color: whitesmoke;
                image-rendering: pixelated;
                image-rendering: crisp-edges;
                margin: auto;
                display: block;
                width: 100%;
                border-radius: 2%;
            }
        </style>
    </head>
    <body class="body">
        <div id="top-bun">
            <h1 class="sesame-seeds">Farmunation</h1>
            <p class="fluff">update description</p>
        </div>
        <div>
            <canvas id="main" width="512" height="512"></canvas>
        </div>
        <div id="bottom-bun">
            <footer>
                <ul>
                    <p class="fluff">Started By Ethan Huber On 11/5/22</p>
                    <a style="text-decoration: none" href="https://x.com"><p class="b">Website</p></a>
                    <a style="text-decoration: none" href="https://github.com/zushiEdu/Farmunation"><p class="b">Farmunation</p></a>
                    <a style="text-decoration: none" href="https://github.com/zushiEdu/"><p class="b">Github</p></a>
                </ul>
            </footer>
        </div>

        <script>
            function implement(posx, posy, rot, active, name, toolType, ax, ay, inventory, reference) {
                this.posx = posx;
                this.posy = posy;
                this.rot = rot;
                this.active = active;
                this.name = name;
                this.toolType = toolType;
                this.ax = ax;
                this.ay = ay;
                this.inventory = inventory;
                this.reference = reference;
            }
            function tile(state, willGrow, tillGrown, yield, cropType) {
                this.state = state;
                this.willGrow = willGrow;
                this.tillGrown = tillGrown;
                this.yield = yield;
                this.cropType = cropType;
            }
            function vehicle(posx, posy, rotation, attachedImplement, implementAttached, fuel, name, aoX, aoY, inventory, reference) {
                this.posx = posx;
                this.posy = posy;
                this.rotation = rotation;
                this.attachedImplement = attachedImplement;
                this.implementAttached = implementAttached;
                this.fuel = fuel;
                this.name = name;
                this.aoX = aoX;
                this.aoY = aoY;
                this.inventory = inventory;
                this.reference = reference;
            }
            function item(name, amount) {
                this.name = name;
                this.amount = amount;
            }
            function prompt(posx, posy, width, height, elements) {
                this.posx = posx;
                this.posy = posy;
                this.width = width;
                this.height = height;
                this.elements = elements;
            }
            function element(text, action) {
                this.text = text;
                this.action = action;
            }
            function specialLocation(posx, posy, action) {
                this.posx = posx;
                this.posy = posy;
                this.action = action;
            }
            function machine(name, price, size, type, image, attachableTo) {
                this.name = name;
                this.price = price;
                this.size = size;
                this.type = type;
                this.image = image;
                this.attachableTo = attachableTo;
            }

            const spriteSize = 16;
            const c = document.getElementById("main");
            const button = document.querySelector("#main");
            button.addEventListener("click", mouseClick, false);
            const painter = c.getContext("2d", { alpha: false });
            var rendererOffset = 8;
            painter.translate(rendererOffset, rendererOffset);
            painter.imageSmoothingEnabled = false;

            const width = c.width;
            const height = c.height;
            const centerX = width / 2;
            const centerY = height / 2;

            var pointerX = 0;
            var pointerY = 0;

            var chunkX = 0;
            var chunkY = 0;

            const canvasSize = width / spriteSize;
            const mapSize = canvasSize * 8;
            const mapScale = 8;

            var tileImages = new Array();
            var amountOfCrops = 8;
            fillImageArray(tileImages, amountOfCrops);

            tileImages[0].src = `/${spriteSize}xSprites/Grass.png`;
            tileImages[1].src = `/${spriteSize}xSprites/Cultivated.png`;
            tileImages[2].src = `/${spriteSize}xSprites/PlantedStage1.png`;
            tileImages[3].src = `/${spriteSize}xSprites/PlantedStage3.png`;
            tileImages[4].src = `/${spriteSize}xSprites/PlantedStage5.png`;
            tileImages[5].src = `/${spriteSize}xSprites/PlantedStage6.png`;
            tileImages[6].src = `/${spriteSize}xSprites/Harvested.png`;
            tileImages[7].src = `/${spriteSize}xSprites/SellPoint.png`;

            var machines = new Array();
            var amountOfMachines = 8;
            fillImageArray(machines, amountOfMachines);

            machines[0].src = `/${spriteSize}xSprites/Tractor.png`;
            machines[1].src = `/${spriteSize}xSprites/Cultivator.png`;
            machines[2].src = `/${spriteSize}xSprites/Planter.png`;
            machines[3].src = `/${spriteSize}xSprites/Harvester.png`;
            machines[4].src = `/${spriteSize}xSprites/GrainHeader.png`;
            machines[5].src = `/${spriteSize}xSprites/LargeCultivator.png`;
            machines[6].src = `/${spriteSize}xSprites/GrainTrailer.png`;
            machines[7].src = `/${spriteSize}xSprites/LargePlanter.png`;

            var blocks = [[new tile()]];

            var specialLocations = new Array();

            var prompts = new Array();

            var farmMoney = 225000;

            var implements = new Array();
            var activeVehicle = 0;
            var vehicles = new Array();

            var purchaseableEquipment = new Array();
            // list of all the machines within the game
            // to add more machines add the sprite to the machines list above and add a purchaseable equipment item to the list below
            purchaseableEquipment[0] = new machine("Tractor", 50000, "Small", "vehicle", machines[0], null);
            purchaseableEquipment[1] = new machine("Harvester", 75000, "Small", "vehicle", machines[3], null);
            purchaseableEquipment[2] = new machine("Grain Header", 15000, "Small", "implement", machines[4], "Harvester");
            purchaseableEquipment[3] = new machine("Disc Harrow", 25000, "Small", "implement", machines[1], "Tractor");
            purchaseableEquipment[4] = new machine("Planter", 25000, "Small", "implement", machines[2], "Tractor");
            purchaseableEquipment[5] = new machine("Grain Trailer", 25000, "Small", "implement", machines[6], "Tractor");
            purchaseableEquipment[6] = new machine("Disc Harrow", 50000, "Large", "implement", machines[5], "Tractor");
            purchaseableEquipment[7] = new machine("Planter", 50000, "Large", "implement", machines[7], "Tractor");

            function setup() {
                // create basic map
                prompts[prompts.length] = new prompt(50, 60, 412, 60, [new element("Please Buy A Vehicle To Get Started", null)]);
                showControls();

                for (var y = 0; y <= mapSize; y++) {
                    blocks[y] = [];
                    for (var x = 0; x <= mapSize; x++) {
                        blocks[y][x] = new tile(0, false, null, null);
                    }
                }

                // sellpoint
                // first line sets the logical location of the sellpoint
                // second line sets the visual location of the selllpoint
                // specialLocations[0] = new specialLocation(15, 30, null);
                // blocks[30][15] = new tile(7, false, null, null);

                setTimeout(renderMap, 100);
            }

            function update() {
                if (vehicles[0] == null) {
                    userInterface();
                } else {
                    updateMap();
                    paintMachines();
                    userInterface();
                    applyImplements();
                }
            }

            function adjustChunk() {
                if (chunkX != Math.floor(vehicles[activeVehicle].posx / canvasSize)) {
                    renderMap();
                } else {
                    chunkX = Math.floor(vehicles[activeVehicle].posx / canvasSize);
                    chunkY = Math.floor(vehicles[activeVehicle].posy / canvasSize);
                }
                if (chunkY != Math.floor(vehicles[activeVehicle].posy / canvasSize)) {
                    renderMap();
                } else {
                    chunkX = Math.floor(vehicles[activeVehicle].posx / canvasSize);
                    chunkY = Math.floor(vehicles[activeVehicle].posy / canvasSize);
                }
            }

            function calculateGrainCost(amount) {
                return amount * 5 - amount * 0.5;
            }

            function fillImageArray(array, number) {
                for (var i = 0; i < number; i++) {
                    array[i] = new Image();
                }
            }

            function showControls() {
                prompts[prompts.length] = new prompt(50, 130, 412, 210, [
                    new element("N Shows Vehicle Buy Menu"),
                    new element("B Shows Seed Buy Menu"),
                    new element("P Re-Renders The Screen"),
                    new element("E Switches Vehicles"),
                    new element("Q Attaches Implements"),
                    new element("V Activates Implements"),
                    new element("C Shows Controls"),
                ]);
            }

            function paintMachines() {
                for (var i = 0; i < vehicles.length; i++) {
                    paintMachine(vehicles[i]);
                }
                for (var i = 0; i < implements.length; i++) {
                    paintMachine(implements[i]);
                }
            }

            function paintMachine(object) {
                var osX = chunkX * spriteSize * canvasSize;
                var osY = chunkY * spriteSize * canvasSize;

                if (object.reference.type == "implement") {
                    if (object.ax != 0 && object.ay != 0) {
                        paintImage(
                            object.reference.image,
                            spriteSize * (object.posx - object.ax * Math.cos(toRadian(object.rot))) - osX,
                            spriteSize * (object.posy + object.ay * Math.sin(toRadian(object.rot))) - osY,
                            object.rot
                        );
                    } else {
                        paintImage(object.reference.image, spriteSize * object.posx - osX, spriteSize * object.posy - osY, object.rot);
                    }
                } else if (object.reference.type == "vehicle") {
                    paintImage(object.reference.image, spriteSize * object.posx - osX, spriteSize * object.posy - osY, object.rotation);
                }
            }

            function userInterface() {
                // ui
                roundedRect(0, 0, 512 - 16 - 100, 20, 5, 0, 0, 0);
                roundedRect(512 - 16 - 100 + 10, 0, 90, 20, 5, 0, 0, 0);
                roundedRect(512 - 16 - 100 + 10, 25, 90, 20, 5, 0, 0, 0);

                // tool display computing
                var at;
                var bt;
                if (vehicles[0] != null) {
                    if (vehicles[activeVehicle].implementAttached) {
                        if (implements[vehicles[activeVehicle].attachedImplement].active) {
                            ct = "Tool On";
                        } else {
                            ct = "Tool Off";
                        }
                        if (implements[vehicles[activeVehicle].attachedImplement].inventory != null) {
                            at =
                                ", " +
                                implements[vehicles[activeVehicle].attachedImplement].name +
                                ": " +
                                implements[vehicles[activeVehicle].attachedImplement].inventory.name +
                                ", " +
                                implements[vehicles[activeVehicle].attachedImplement].inventory.amount +
                                " [" +
                                ct +
                                "]";
                        } else {
                            at = ", " + implements[vehicles[activeVehicle].attachedImplement].name + " [" + ct + "]";
                        }
                    } else {
                        at = "";
                    }
                    if (vehicles[activeVehicle].inventory == null) {
                        bt = "";
                    } else {
                        bt = ": " + vehicles[activeVehicle].inventory.name + ", " + vehicles[activeVehicle].inventory.amount;
                    }

                    // tool display
                    drawText(vehicles[activeVehicle].name + bt + at, 5, 15, 255, 255, 255);
                    drawText(vehicles[activeVehicle].posx + ", " + vehicles[activeVehicle].posy, 512 - 16 - 80, 15, 255, 255, 255);
                }
                drawText("$" + farmMoney, 512 - 16 - 80, 40, 255, 255, 255);
                displayPrompts();
            }

            function applyImplements() {
                if (vehicles[activeVehicle].implementAttached) {
                    if (implements[vehicles[activeVehicle].attachedImplement].active) {
                        var ax = implements[vehicles[activeVehicle].attachedImplement].ax;
                        var ay = implements[vehicles[activeVehicle].attachedImplement].ay;

                        if (
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 0 ||
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 6 ||
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 2 ||
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 1
                        ) {
                            // cultivate land
                            if (implements[vehicles[activeVehicle].attachedImplement].name == "Disc Harrow") {
                                blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx] =
                                    new tile(1, false, null, null, "Cultivated");
                                if (implements[vehicles[activeVehicle].attachedImplement].ax != 0) {
                                    blocks[
                                        implements[vehicles[activeVehicle].attachedImplement].posy +
                                            implements[vehicles[activeVehicle].attachedImplement].ay *
                                                Math.round(Math.sin(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                    ][
                                        implements[vehicles[activeVehicle].attachedImplement].posx -
                                            implements[vehicles[activeVehicle].attachedImplement].ax *
                                                Math.round(Math.cos(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                    ] = new tile(1, false, null, null, "Cultivated");
                                    blocks[
                                        implements[vehicles[activeVehicle].attachedImplement].posy -
                                            implements[vehicles[activeVehicle].attachedImplement].ay *
                                                Math.round(Math.sin(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                    ][
                                        implements[vehicles[activeVehicle].attachedImplement].posx +
                                            implements[vehicles[activeVehicle].attachedImplement].ax *
                                                Math.round(Math.cos(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                    ] = new tile(1, false, null, null, "Cultivated");
                                }
                            }
                        } else if (
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 2
                        ) {
                            // fertilize crop
                            if (implements[vehicles[activeVehicle].attachedImplement].name == "Sprayer") {
                                blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx] =
                                    new tile(
                                        2,
                                        true,
                                        blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                            implements[vehicles[activeVehicle].attachedImplement].posx
                                        ].yield + 0.25,
                                        blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                            implements[vehicles[activeVehicle].attachedImplement].posx
                                        ].cropType
                                    );
                            }
                        } else if (
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 5
                        ) {
                            if (implements[vehicles[activeVehicle].attachedImplement].name == "Grain Header") {
                                if (vehicles[activeVehicle].inventory == null) {
                                    vehicles[activeVehicle].inventory = new item("Grain", 0);
                                }
                                console.log(vehicles[activeVehicle].inventory);
                                if (vehicles[activeVehicle].inventory.name == "Grain") {
                                    vehicles[activeVehicle].inventory.amount +=
                                        1 *
                                        blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                            implements[vehicles[activeVehicle].attachedImplement].posx
                                        ].yield;

                                    blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                        implements[vehicles[activeVehicle].attachedImplement].posx
                                    ] = new tile(6, false, null, null);
                                }
                            }
                            // harvest crop
                            // calculate yield and what to deposit based on crop type
                        }

                        // plant crop on land
                        if (implements[vehicles[activeVehicle].attachedImplement].name == "Planter") {
                            if (implements[vehicles[activeVehicle].attachedImplement].inventory.amount >= 1) {
                                if (
                                    blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                        implements[vehicles[activeVehicle].attachedImplement].posx
                                    ].state == 1
                                ) {
                                    blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                        implements[vehicles[activeVehicle].attachedImplement].posx
                                    ] = new tile(2, true, 5, 0.5, implements[vehicles[activeVehicle].attachedImplement].inventory.name);
                                    implements[vehicles[activeVehicle].attachedImplement].inventory.amount -= 1;
                                }
                                if (implements[vehicles[activeVehicle].attachedImplement].ax != 0) {
                                    if (
                                        blocks[
                                            implements[vehicles[activeVehicle].attachedImplement].posy +
                                                implements[vehicles[activeVehicle].attachedImplement].ay *
                                                    Math.round(Math.sin(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                        ][
                                            implements[vehicles[activeVehicle].attachedImplement].posx -
                                                implements[vehicles[activeVehicle].attachedImplement].ax *
                                                    Math.round(Math.cos(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                        ].state == 1
                                    ) {
                                        blocks[
                                            implements[vehicles[activeVehicle].attachedImplement].posy +
                                                implements[vehicles[activeVehicle].attachedImplement].ay *
                                                    Math.round(Math.sin(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                        ][
                                            implements[vehicles[activeVehicle].attachedImplement].posx -
                                                implements[vehicles[activeVehicle].attachedImplement].ax *
                                                    Math.round(Math.cos(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                        ] = new tile(2, true, 5, 0.5, implements[vehicles[activeVehicle].attachedImplement].inventory.name);
                                        implements[vehicles[activeVehicle].attachedImplement].inventory.amount -= 1;
                                    }
                                    if (
                                        blocks[
                                            implements[vehicles[activeVehicle].attachedImplement].posy -
                                                implements[vehicles[activeVehicle].attachedImplement].ay *
                                                    Math.round(Math.sin(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                        ][
                                            implements[vehicles[activeVehicle].attachedImplement].posx +
                                                implements[vehicles[activeVehicle].attachedImplement].ax *
                                                    Math.round(Math.cos(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                        ].state == 1
                                    ) {
                                        blocks[
                                            implements[vehicles[activeVehicle].attachedImplement].posy -
                                                implements[vehicles[activeVehicle].attachedImplement].ay *
                                                    Math.round(Math.sin(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                        ][
                                            implements[vehicles[activeVehicle].attachedImplement].posx +
                                                implements[vehicles[activeVehicle].attachedImplement].ax *
                                                    Math.round(Math.cos(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                        ] = new tile(2, true, 5, 0.5, implements[vehicles[activeVehicle].attachedImplement].inventory.name);
                                        implements[vehicles[activeVehicle].attachedImplement].inventory.amount -= 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function displayPrompts() {
                for (var i = 0; i < prompts.length; i++) {
                    if (prompts[i] != null) {
                        roundedRect(prompts[i].posx, prompts[i].posy, prompts[i].width, prompts[i].height, 5, 0, 0, 0);
                        roundedRect(prompts[i].posx + 10, prompts[i].posy + 10, 20, 14, 7, 255, 0, 0);
                        drawText("X", prompts[i].posx + 15, prompts[i].posy + 10 + 11, 255, 255, 255);
                        for (var j = 0; j < prompts[i].elements.length; j++) {
                            if (prompts[i].elements[j].action == null) {
                                roundedRect(prompts[i].posx + 10, 5 + prompts[i].posy + (j + 1) * 25, prompts[i].width - 20, 20, 8, 50, 50, 50);
                                drawText(prompts[i].elements[j].text, prompts[i].posx + 20, 20 + prompts[i].posy + (j + 1) * 25, 255, 255, 255);
                            } else if (prompts[i].elements[j].action != null) {
                                roundedRect(prompts[i].posx + 10, 5 + prompts[i].posy + (j + 1) * 25, prompts[i].width - 20, 20, 8, 100, 100, 100);
                                drawText(prompts[i].elements[j].text, prompts[i].posx + 20, 20 + prompts[i].posy + (j + 1) * 25, 255, 255, 255);
                            }
                        }
                    }
                }
            }

            function mouseClick() {
                for (var i = 0; i < prompts.length; i++) {
                    if (prompts[i] != null) {
                        for (var j = 0; j < prompts[i].elements.length; j++) {
                            if (pointerX > prompts[i].posx + 10 && pointerX < prompts[i].posx + prompts[i].width - 20) {
                                // within element horizontally
                                if (pointerY > 10 + prompts[i].posy + (j + 1) * 25 && pointerY < 30 + prompts[i].posy + (j + 1) * 25) {
                                    // within element vertically

                                    if (prompts[i].elements[j].action != null) {
                                        // button pressed
                                        eval(`${prompts[i].elements[j].action}`);
                                    }
                                }
                            }
                        }
                        if (
                            pointerX >= prompts[i].posx + 10 &&
                            pointerX <= prompts[i].posx + 40 &&
                            pointerY >= prompts[i].posy + 10 &&
                            pointerY <= prompts[i].posy + 30
                        ) {
                            prompts[i] = null;
                            renderMap();
                        }
                    }
                }
            }

            function buyGrain(amount) {
                if (vehicles[activeVehicle].implementAttached) {
                    if (implements[vehicles[activeVehicle].attachedImplement].name == "Planter") {
                        if (farmMoney >= calculateGrainCost(amount)) {
                            if (implements[vehicles[activeVehicle].attachedImplement].inventory == null) {
                                implements[vehicles[activeVehicle].attachedImplement].inventory = new item("Grain", 0);
                            }
                            implements[vehicles[activeVehicle].attachedImplement].inventory.amount += amount;

                            farmMoney -= calculateGrainCost(amount);
                            prompts[prompts.length] = new prompt(50, 225, 412, 60, [
                                new element(`${amount} units of grain successfully bought, $${calculateGrainCost(amount)} spent`, null),
                            ]);
                        } else {
                            prompts[prompts.length] = new prompt(50, 225, 412, 60, [new element("Not Enough Money", null)]);
                        }
                    } else {
                        prompts[prompts.length] = new prompt(50, 225, 412, 60, [new element("Planter Not Attached", null)]);
                    }
                } else {
                    prompts[prompts.length] = new prompt(50, 225, 412, 60, [new element("No Tool Attached", null)]);
                }
            }

            function moveVehicle(f) {
                if (f) {
                    vehicles[activeVehicle].posy += Math.round(Math.cos(toRadian(vehicles[activeVehicle].rotation)));
                    vehicles[activeVehicle].posx -= Math.round(Math.sin(toRadian(vehicles[activeVehicle].rotation)));
                } else {
                    vehicles[activeVehicle].posy -= Math.round(Math.cos(toRadian(vehicles[activeVehicle].rotation)));
                    vehicles[activeVehicle].posx += Math.round(Math.sin(toRadian(vehicles[activeVehicle].rotation)));
                }
            }

            function moveImplement(f) {
                if (f) {
                    implements[vehicles[activeVehicle].attachedImplement].posx = vehicles[activeVehicle].posx;
                    implements[vehicles[activeVehicle].attachedImplement].posy = vehicles[activeVehicle].posy;
                    implements[vehicles[activeVehicle].attachedImplement].rot = vehicles[activeVehicle].rotation;
                } else {
                    implements[vehicles[activeVehicle].attachedImplement].posx += Math.round(Math.sin(toRadian(vehicles[activeVehicle].rotation)));
                    implements[vehicles[activeVehicle].attachedImplement].posy -= Math.round(Math.cos(toRadian(vehicles[activeVehicle].rotation)));
                    implements[vehicles[activeVehicle].attachedImplement].rot = vehicles[activeVehicle].rotation;
                }
            }

            function input(key) {
                if (key == "w") {
                    if (vehicles[activeVehicle].aoX == 0) {
                        moveVehicle(true);
                    }
                    if (vehicles[activeVehicle].implementAttached) {
                        moveImplement(true);
                    }

                    if (vehicles[activeVehicle].aoX != 0) {
                        moveVehicle(true);
                    }
                    adjustChunk();
                }
                if (key == "s") {
                    moveVehicle(false);
                    if (vehicles[activeVehicle].implementAttached) {
                        moveImplement(false);
                    }
                    adjustChunk();
                }
                if (key == "d") {
                    if (vehicles[activeVehicle].aoX == 0) {
                        if (vehicles[activeVehicle].rotation + 45 == 225) {
                            vehicles[activeVehicle].rotation = -135;
                        } else {
                            vehicles[activeVehicle].rotation += 45;
                        }
                    }
                    if (vehicles[activeVehicle].implementAttached) {
                        implements[vehicles[activeVehicle].attachedImplement].rot = vehicles[activeVehicle].rotation;
                    }
                    if (vehicles[activeVehicle].aoX != 0) {
                        if (vehicles[activeVehicle].rotation + 45 == 225) {
                            vehicles[activeVehicle].rotation = -135;
                        } else {
                            vehicles[activeVehicle].rotation += 45;
                        }
                    }
                    adjustChunk();
                }
                if (key == "a") {
                    if (vehicles[activeVehicle].aoX == 0) {
                        if (vehicles[activeVehicle].rotation - 45 == -225) {
                            vehicles[activeVehicle].rotation = 135;
                        } else {
                            if (vehicles[activeVehicle].rotation - 45 == -180) {
                                vehicles[activeVehicle].rotation = 180;
                            } else {
                                vehicles[activeVehicle].rotation -= 45;
                            }
                        }
                    }
                    if (vehicles[activeVehicle].implementAttached) {
                        implements[vehicles[activeVehicle].attachedImplement].rot = vehicles[activeVehicle].rotation;
                    }
                    if (vehicles[activeVehicle].aoX != 0) {
                        if (vehicles[activeVehicle].rotation - 45 == -225) {
                            vehicles[activeVehicle].rotation = 135;
                        } else {
                            if (vehicles[activeVehicle].rotation - 45 == -180) {
                                vehicles[activeVehicle].rotation = 180;
                            } else {
                                vehicles[activeVehicle].rotation -= 45;
                            }
                        }
                    }
                    adjustChunk();
                }
                if (key == "v") {
                    if (vehicles[activeVehicle].implementAttached) {
                        if (implements[vehicles[activeVehicle].attachedImplement].active) {
                            implements[vehicles[activeVehicle].attachedImplement].active = false;
                        } else {
                            implements[vehicles[activeVehicle].attachedImplement].active = true;
                        }
                    }
                }
                if (key == "q") {
                    if (vehicles[activeVehicle].implementAttached) {
                        vehicles[activeVehicle].implementAttached = false;
                    } else {
                        for (var i = 0; i < implements.length; i++) {
                            if (implements[i].toolType == vehicles[activeVehicle].name) {
                                if (implements[i].posy == vehicles[activeVehicle].posy) {
                                    if (
                                        implements[i].rot == 90 &&
                                        vehicles[activeVehicle].rotation == 90 &&
                                        implements[i].posx - vehicles[activeVehicle].posx == -vehicles[activeVehicle].aoX
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    } else if (
                                        implements[i].rot == -90 &&
                                        vehicles[activeVehicle].rotation == -90 &&
                                        implements[i].posx - vehicles[activeVehicle].posx == vehicles[activeVehicle].aoX
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    }
                                } else if (implements[i].posx == vehicles[activeVehicle].posx) {
                                    if (
                                        implements[i].rot == 0 &&
                                        vehicles[activeVehicle].rotation == 0 &&
                                        implements[i].posy - vehicles[activeVehicle].posy == vehicles[activeVehicle].aoY
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    } else if (
                                        implements[i].rot == 180 &&
                                        vehicles[activeVehicle].rotation == 180 &&
                                        implements[i].posy - vehicles[activeVehicle].posy == -vehicles[activeVehicle].aoY
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    }
                                } else if (
                                    distanceBetweenPoints(implements[i].posx, implements[i].posy, vehicles[activeVehicle].posx, vehicles[activeVehicle].posy) <=
                                        1.5 ||
                                    distanceBetweenPoints(implements[i].posx, implements[i].posy, vehicles[activeVehicle].posx, vehicles[activeVehicle].posy) <=
                                        -1.5
                                ) {
                                    vehicles[activeVehicle].implementAttached = true;
                                    vehicles[activeVehicle].attachedImplement = i;
                                }
                            }
                        }
                    }
                }
                if (key == "e") {
                    if (activeVehicle < vehicles.length - 1) {
                        activeVehicle++;
                    } else {
                        activeVehicle = 0;
                    }
                }
                if (key == "c") {
                    for (var y = 0; y < blocks.length; y++) {
                        for (var x = 0; x < blocks[y].length; x++) {
                            if (blocks[y][x].willGrow) {
                                if (blocks[y][x].state + 1 < 6) {
                                    blocks[y][x].tillGrown -= 1;
                                    blocks[y][x].state += 1;
                                }
                            }
                        }
                    }
                    renderMap();
                }
                if (key == "r") {
                    if (vehicles[activeVehicle].name == "Harvester") {
                        if (implements[4].rot == vehicles[activeVehicle].rotation) {
                            // same rotation
                            if (implements[4].posy - vehicles[activeVehicle].posy == 1 || implements[4].posy - vehicles[activeVehicle].posy == -1) {
                                if (implements[4].posx - vehicles[activeVehicle].posx == 0) {
                                    if (vehicles[activeVehicle].rotation == 90 || vehicles[activeVehicle].rotation == -90) {
                                        implements[4].inventory.amount += vehicles[activeVehicle].inventory.amount;
                                        vehicles[activeVehicle].inventory.amount = 0;
                                    }
                                }
                            } else if (implements[4].posx - vehicles[activeVehicle].posx == 1 || implements[4].posx - vehicles[activeVehicle].posx == -1) {
                                if (implements[4].posy - vehicles[activeVehicle].posy == 0) {
                                    if (vehicles[activeVehicle].rotation == 0 || vehicles[activeVehicle].rotation == 180) {
                                        implements[4].inventory.amount += vehicles[activeVehicle].inventory.amount;
                                        vehicles[activeVehicle].inventory.amount = 0;
                                    }
                                }
                            }
                        }
                    }
                    if (implements[vehicles[activeVehicle].attachedImplement].name == "Grain Trailer") {
                        for (var i = 0; i < specialLocations.length; i++) {
                            if (
                                implements[vehicles[activeVehicle].attachedImplement].posx == specialLocations[i].posx &&
                                implements[vehicles[activeVehicle].attachedImplement].posy == specialLocations[i].posy
                            ) {
                                farmMoney += 3 * calculateGrainCost(implements[vehicles[activeVehicle].attachedImplement].inventory.amount);
                                implements[vehicles[activeVehicle].attachedImplement].inventory.amount = 0;
                            }
                        }
                    }
                }
                if (key == "b") {
                    prompts[prompts.length] = new prompt(50, 50, 412, 160, [
                        new element("Buy Grain", null),
                        new element(`Buy 10 Units Of Grain For $${calculateGrainCost(10)}`, "buyGrain(10)"),
                        new element(`Buy 100 Units Of Grain For $${calculateGrainCost(100)}`, "buyGrain(100)"),
                        new element(`Buy 500 Units Of Grain For $${calculateGrainCost(500)}`, "buyGrain(500)"),
                        new element(`Buy 1000 Units Of Grain For $${calculateGrainCost(1000)}`, "buyGrain(1000)"),
                    ]);
                }
                if (key == "n") {
                    prompts[prompts.length] = new prompt(50, 50, 412, 260, [new element("Huber Ag Ltd.", null)]);
                    for (var i = 0; i < purchaseableEquipment.length; i++) {
                        var text = `Buy ${purchaseableEquipment[i].size} ${purchaseableEquipment[i].name} for $${purchaseableEquipment[i].price}`;
                        prompts[prompts.length - 1].elements[i + 1] = new element(text, `buyEquipment(purchaseableEquipment[${i}])`);
                    }
                }
                if (key == "p") {
                    renderMap();
                }
                if (key == "c") {
                    showControls();
                }
            }

            function buyEquipment(machine) {
                if (farmMoney >= machine.price) {
                    if (machine.type == "vehicle") {
                        if (machine.name == "Tractor") {
                            vehicles[vehicles.length] = new vehicle(30, 3, -90, null, null, 100, machine.name, 1, 1, null, machine);
                            farmMoney -= machine.price;
                        } else if (machine.name == "Harvester") {
                            vehicles[vehicles.length] = new vehicle(30, 3, -90, null, null, 100, machine.name, 0, 0, new item("Grain", 0), machine);
                            farmMoney -= machine.price;
                        }
                    } else if (machine.type == "implement") {
                        if (machine.size == "Small") {
                            implements[implements.length] = new implement(30, 3, -90, null, machine.name, machine.attachableTo, 0, 0, null, machine);
                            farmMoney -= machine.price;
                        } else if (machine.size == "Large") {
                            implements[implements.length] = new implement(30, 3, -90, null, machine.name, machine.attachableTo, -1, 1, null, machine);
                            farmMoney -= machine.price;
                        }
                    }
                } else {
                    prompts[prompts.length] = new prompt(50, 225, 412, 60, [new element("Not Enough Money", null)]);
                }
            }

            function distanceBetweenPoints(x1, y1, x2, y2) {
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            }

            function renderMap() {
                for (var y = chunkY * canvasSize; y < (chunkY + 1) * canvasSize; y++) {
                    for (var x = chunkX * canvasSize; x < (chunkX + 1) * canvasSize; x++) {
                        paintImage(
                            tileImages[blocks[y][x].state],
                            x * spriteSize - chunkX * spriteSize * canvasSize,
                            y * spriteSize - chunkY * spriteSize * canvasSize,
                            0
                        );
                    }
                }
            }

            function updateMap() {
                for (var i = 0; i < implements.length; i++) {
                    for (var y = -2; y <= 2; y++) {
                        for (var x = -2; x <= 2; x++) {
                            if (
                                implements[i].posx + x >= 0 &&
                                implements[i].posx + x <= mapSize &&
                                implements[i].posy + y >= 0 &&
                                implements[i].posy + y <= mapSize
                            ) {
                                paintImage(
                                    tileImages[blocks[implements[i].posy + y][implements[i].posx + x].state],
                                    (implements[i].posx + x) * spriteSize - chunkX * spriteSize * canvasSize,
                                    (implements[i].posy + y) * spriteSize - chunkY * spriteSize * canvasSize,
                                    0
                                );
                            }
                        }
                    }
                }
                for (var i = 0; i < vehicles.length; i++) {
                    for (var y = -2; y <= 2; y++) {
                        for (var x = -2; x <= 2; x++) {
                            if (vehicles[i].posx + x >= 0 && vehicles[i].posx + x <= mapSize && vehicles[i].posy + y >= 0 && vehicles[i].posy + y <= mapSize) {
                                paintImage(
                                    tileImages[blocks[vehicles[i].posy + y][vehicles[i].posx + x].state],
                                    (vehicles[i].posx + x) * spriteSize - chunkX * spriteSize * canvasSize,
                                    (vehicles[i].posy + y) * spriteSize - chunkY * spriteSize * canvasSize,
                                    0
                                );
                            }
                        }
                    }
                }
            }

            function paintImage(image, x, y, angle) {
                painter.save();
                painter.translate(x, y);
                painter.rotate(toRadian(180 + angle));
                painter.drawImage(image, -1 * (spriteSize / 2), -1 * (spriteSize / 2));
                painter.restore();
            }

            function toRadian(angle) {
                return (180 + angle) * (Math.PI / 180);
            }

            function clearScreen() {
                painter.clearRect(0, 0, width, height);
            }

            function findSlope(y2, y1, x2, x1) {
                return ((y2 - y1) / (x2 - x1)) * -1;
            }

            function drawRect(x1, y1, x2, y2, r, g, b) {
                painter.strokeStyle = "rgb(" + r + "," + g + "," + b + ")";
                painter.beginPath();
                painter.fillRect(x1, y1, x2, y2);
                painter.closePath();
            }

            function roundedRect(x, y, width, height, radius, r, g, b) {
                painter.beginPath();
                painter.moveTo(x, y + radius);
                painter.arcTo(x, y + height, x + radius, y + height, radius);
                painter.arcTo(x + width, y + height, x + width, y + height - radius, radius);
                painter.arcTo(x + width, y, x + width - radius, y, radius);
                painter.arcTo(x, y, x, y + radius, radius);
                painter.strokeStyle = "rgb(" + r + "," + g + "," + b + ")";
                painter.stroke();
                painter.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
                painter.fill();
                painter.closePath();
            }

            function drawText(text, x, y, r, g, b) {
                painter.beginPath();
                painter.font = "15px Arial";
                painter.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
                painter.fillText(text, x, y + 1);
                painter.closePath();
            }

            function drawCircle(sX, sY, hStretch, vStretch, rotation, r, g, b) {
                painter.beginPath();
                painter.strokeStyle = "rgb(" + r + "," + g + "," + b + ")";
                painter.ellipse(sX, sY, hStretch, vStretch, rotation, 0, 360);
                painter.stroke();
                painter.fill();
                painter.closePath();
            }

            function drawLine(sX, sY, eX, eY, r, g, b) {
                painter.beginPath();
                painter.strokeStyle = `rgb(${r},${g},${b})`;
                painter.moveTo(sX, sY);
                painter.lineTo(eX, eY);
                painter.closePath();
                painter.stroke();
            }

            document.addEventListener(
                "keydown",
                (event) => {
                    var name = event.key;
                    input(name);
                },
                false
            );

            document.onmousemove = function (event) {
                const target = event.target;
                const rect = target.getBoundingClientRect();
                var wRatio = (rect.right - rect.left) / width;
                var hRatio = (rect.bottom - rect.top) / height;
                pointerX = (event.pageX - window.scrollX - rect.left) / wRatio;
                pointerY = (event.pageY - window.scrollY - rect.top) / hRatio;
            };

            setup();
            setInterval(update, 1 / 30);
        </script>
    </body>
</html>
