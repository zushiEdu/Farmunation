<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Farmunation</title>
        <link rel="icon" type="image/x-icon" href="/Sprites/Tractor.png" />
        <style>
            body {
                margin: 0;
            }
            canvas {
                background-color: whitesmoke;
                image-rendering: pixelated;
                image-rendering: crisp-edges;
            }
        </style>
    </head>
    <body>
        <canvas id="main" width="512" height="512"></canvas>

        <script>
            function implement(posx, posy, rot, active, name, bF, aF, toolType, ax, ay, bx, by) {
                this.posx = posx;
                this.posy = posy;
                this.rot = rot;
                this.active = active;
                this.name = name;
                this.bF = bF;
                this.aF = aF;
                this.toolType = toolType;
                this.ax = ax;
                this.ay = ay;
                this.bx = bx;
                this.by = by;
            }
            function tile(state, willGrow, tillGrown, yield, cropType) {
                this.state = state;
                this.willGrow = willGrow;
                this.tillGrown = tillGrown;
                this.yield = yield;
                this.cropType = cropType;
            }
            function vehicle(posx, posy, rotation, attachedImplement, implementAttached, fuel, name, aoX, aoY, inventory) {
                this.posx = posx;
                this.posy = posy;
                this.rotation = rotation;
                this.attachedImplement = attachedImplement;
                this.implementAttached = implementAttached;
                this.fuel = fuel;
                this.name = name;
                this.aoX = aoX;
                this.aoY = aoY;
                this.inventory = inventory;
            }

            const spriteSize = 16;

            const c = document.getElementById("main");
            const painter = c.getContext("2d", { alpha: false });
            //painter.scale(2, 2);
            painter.translate(8, 8);
            painter.imageSmoothingEnabled = false;

            const width = c.width;
            const height = c.height;
            const centerX = width / 2;
            const centerY = height / 2;

            var pointerX = 0;
            var pointerY = 0;

            var implements = new Array();
            // TO = tool offset
            //                            X, Y, R,  On,    Name,        TOX,TOY, Matching Vehicle
            implements[0] = new implement(2, 2, 90, false, "Disc Harrow", 0, 1, "Tractor", 0, 0, 0, 0);
            implements[1] = new implement(2, 4, 90, false, "Planter", 1, 2, "Tractor", 0, 0, 0, 0);
            implements[2] = new implement(2, 10, 90, false, "Corn Header", 5, 6, "Harvester", 0, 0, 0, 0);
            implements[3] = new implement(2, 13, 90, false, "Disc Harrow", 0, 1, "Tractor", -1, 0, 1, 0);

            var activeVehicle = 0;
            var vehicles = new Array();
            vehicles[0] = new vehicle(2, 6, 90, 0, false, 100, "Tractor", 1, 1);
            vehicles[1] = new vehicle(2, 8, 90, null, false, 100, "Harvester", 0, 0);

            // Image Section
            var matchingImage = new Array();

            matchingImage[0] = new Image();
            matchingImage[0].src = "/Sprites/Grass.png";

            matchingImage[1] = new Image();
            matchingImage[1].src = "/Sprites/Cultivated.png";

            matchingImage[2] = new Image();
            matchingImage[2].src = "/Sprites/PlantedStage1.png";

            matchingImage[3] = new Image();
            matchingImage[3].src = "/Sprites/PlantedStage3.png";

            matchingImage[4] = new Image();
            matchingImage[4].src = "/Sprites/PlantedStage5.png";

            matchingImage[5] = new Image();
            matchingImage[5].src = "/Sprites/PlantedStage6.png";

            matchingImage[6] = new Image();
            matchingImage[6].src = "/Sprites/Harvested.png";

            var machines = new Array();

            machines[0] = new Image();
            machines[0].src = "/Sprites/Tractor.png";

            machines[1] = new Image();
            machines[1].src = "/Sprites/Cultivator.png";

            machines[2] = new Image();
            machines[2].src = "/Sprites/Planter.png";

            machines[3] = new Image();
            machines[3].src = "/Sprites/Harvester.png";

            machines[4] = new Image();
            machines[4].src = "/Sprites/Corn Header.png";

            machines[5] = new Image();
            machines[5].src = "/Sprites/LargeCultivator.png";

            var blocks = [[new tile()]];

            function setup() {
                // create basic map
                for (var y = 0; y <= height / spriteSize; y++) {
                    blocks[y] = [];
                    for (var x = 0; x <= width / spriteSize; x++) {
                        blocks[y][x] = new tile(0, false, null, null);
                    }
                }
            }

            function update() {
                clearScreen();
                updateMap();

                //render all machines
                paintImage(machines[0], spriteSize * vehicles[0].posx, spriteSize * vehicles[0].posy, vehicles[0].rotation);
                paintImage(machines[1], spriteSize * implements[0].posx, spriteSize * implements[0].posy, implements[0].rot);
                paintImage(machines[2], spriteSize * implements[1].posx, spriteSize * implements[1].posy, implements[1].rot);
                paintImage(machines[3], spriteSize * vehicles[1].posx, spriteSize * vehicles[1].posy, vehicles[1].rotation);
                paintImage(machines[4], spriteSize * implements[2].posx, spriteSize * implements[2].posy, implements[2].rot);
                paintImage(machines[5], spriteSize * implements[3].posx, spriteSize * (implements[3].posy - implements[3].bx), implements[3].rot);

                if (vehicles[activeVehicle].implementAttached) {
                    if (implements[vehicles[activeVehicle].attachedImplement].active) {
                        var ax = implements[vehicles[activeVehicle].attachedImplement].ax;
                        var ay = implements[vehicles[activeVehicle].attachedImplement].ay;
                        var bx = implements[vehicles[activeVehicle].attachedImplement].bx;
                        var by = implements[vehicles[activeVehicle].attachedImplement].by;
                        if (
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 0 ||
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 6 ||
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 2
                        ) {
                            // cultivate land
                            if (implements[vehicles[activeVehicle].attachedImplement].name == "Disc Harrow") {
                                for (var y = ay; y <= by; y++) {
                                    for (var x = ax; x <= bx; x++) {
                                        blocks[implements[vehicles[activeVehicle].attachedImplement].posy + y][
                                            implements[vehicles[activeVehicle].attachedImplement].posx + x
                                        ] = new tile(1, false, null, null);
                                    }
                                }
                            }
                        } else if (
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 1
                        ) {
                            // plant crop on land
                            if (implements[vehicles[activeVehicle].attachedImplement].name == "Planter") {
                                blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx] =
                                    new tile(2, true, 5, 0.5, "Wheat");
                            }
                        } else if (
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 2
                        ) {
                            // fertilize crop
                            if (implements[vehicles[activeVehicle].attachedImplement].name == "Sprayer") {
                                blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx] =
                                    new tile(
                                        2,
                                        true,
                                        blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                            implements[vehicles[activeVehicle].attachedImplement].posx
                                        ].yield + 0.25,
                                        blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                            implements[vehicles[activeVehicle].attachedImplement].posx
                                        ].cropType
                                    );
                            }
                        } else if (
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 5
                        ) {
                            if (implements[vehicles[activeVehicle].attachedImplement].name == "Corn Header") {
                                blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx] =
                                    new tile(6, false, null, null);
                            }
                            // harvest crop
                            // calculate yield and what to deposit based on crop type
                        }
                    }
                }
            }

            function input(key) {
                if (key == "w") {
                    console.log(vehicles[activeVehicle]);

                    if (vehicles[activeVehicle].aoX == 0) {
                        vehicles[activeVehicle].posy += Math.round(Math.cos(toRadian(vehicles[activeVehicle].rotation)));
                        vehicles[activeVehicle].posx -= Math.round(Math.sin(toRadian(vehicles[activeVehicle].rotation)));
                    }
                    if (vehicles[activeVehicle].implementAttached) {
                        implements[vehicles[activeVehicle].attachedImplement].posx = vehicles[activeVehicle].posx;
                        implements[vehicles[activeVehicle].attachedImplement].posy = vehicles[activeVehicle].posy;
                        implements[vehicles[activeVehicle].attachedImplement].rot = vehicles[activeVehicle].rotation;
                    }

                    if (vehicles[activeVehicle].aoX != 0) {
                        vehicles[activeVehicle].posy += Math.round(Math.cos(toRadian(vehicles[activeVehicle].rotation)));
                        vehicles[activeVehicle].posx -= Math.round(Math.sin(toRadian(vehicles[activeVehicle].rotation)));
                    }
                }
                if (key == "s") {
                    vehicles[activeVehicle].posy -= Math.round(Math.cos(toRadian(vehicles[activeVehicle].rotation)));
                    vehicles[activeVehicle].posx += Math.round(Math.sin(toRadian(vehicles[activeVehicle].rotation)));

                    if (vehicles[activeVehicle].implementAttached) {
                        implements[vehicles[activeVehicle].attachedImplement].posx += Math.round(
                            Math.sin(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot))
                        );
                        implements[vehicles[activeVehicle].attachedImplement].posy -= Math.round(
                            Math.cos(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot))
                        );
                    }
                }
                if (key == "d") {
                    if (vehicles[activeVehicle].aoX == 0) {
                        if (vehicles[activeVehicle].rotation + 45 == 225) {
                            vehicles[activeVehicle].rotation = -135;
                        } else {
                            vehicles[activeVehicle].rotation += 45;
                        }
                    }
                    if (vehicles[activeVehicle].implementAttached) {
                        implements[vehicles[activeVehicle].attachedImplement].rot = vehicles[activeVehicle].rotation;
                    }
                    if (vehicles[activeVehicle].aoX != 0) {
                        if (vehicles[activeVehicle].rotation + 45 == 225) {
                            vehicles[activeVehicle].rotation = -135;
                        } else {
                            vehicles[activeVehicle].rotation += 45;
                        }
                    }
                }
                if (key == "a") {
                    if (vehicles[activeVehicle].aoX == 0) {
                        if (vehicles[activeVehicle].rotation - 45 == -225) {
                            vehicles[activeVehicle].rotation = 135;
                        } else {
                            if (vehicles[activeVehicle].rotation - 45 == -180) {
                                vehicles[activeVehicle].rotation = 180;
                            } else {
                                vehicles[activeVehicle].rotation -= 45;
                            }
                        }
                    }
                    if (vehicles[activeVehicle].implementAttached) {
                        implements[vehicles[activeVehicle].attachedImplement].rot = vehicles[activeVehicle].rotation;
                    }
                    if (vehicles[activeVehicle].aoX != 0) {
                        if (vehicles[activeVehicle].rotation - 45 == -225) {
                            vehicles[activeVehicle].rotation = 135;
                        } else {
                            if (vehicles[activeVehicle].rotation - 45 == -180) {
                                vehicles[activeVehicle].rotation = 180;
                            } else {
                                vehicles[activeVehicle].rotation -= 45;
                            }
                        }
                    }
                }
                if (key == "v") {
                    if (vehicles[activeVehicle].implementAttached) {
                        if (implements[vehicles[activeVehicle].attachedImplement].active) {
                            implements[vehicles[activeVehicle].attachedImplement].active = false;
                        } else {
                            implements[vehicles[activeVehicle].attachedImplement].active = true;
                        }
                    }
                }
                if (key == "q") {
                    if (vehicles[activeVehicle].implementAttached) {
                        vehicles[activeVehicle].implementAttached = false;
                    } else {
                        for (var i = 0; i < implements.length; i++) {
                            if (implements[i].toolType == vehicles[activeVehicle].name)
                                if (implements[i].posy == vehicles[activeVehicle].posy) {
                                    if (
                                        implements[i].rot == 90 &&
                                        vehicles[activeVehicle].rotation == 90 &&
                                        implements[i].posx - vehicles[activeVehicle].posx == -vehicles[activeVehicle].aoX
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    } else if (
                                        implements[i].rot == -90 &&
                                        vehicles[activeVehicle].rotation == -90 &&
                                        implements[i].posx - vehicles[activeVehicle].posx == vehicles[activeVehicle].aoX
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    }
                                } else if (implements[i].posx == vehicles[activeVehicle].posx) {
                                    console.log(implements[i].posy - vehicles[activeVehicle].posy);
                                    console.log(implements[i].rot + ", " + vehicles[activeVehicle].rotation);
                                    if (
                                        implements[i].rot == 0 &&
                                        vehicles[activeVehicle].rotation == 0 &&
                                        implements[i].posy - vehicles[activeVehicle].posy == vehicles[activeVehicle].aoY
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    } else if (
                                        implements[i].rot == 180 &&
                                        vehicles[activeVehicle].rotation == 180 &&
                                        implements[i].posy - vehicles[activeVehicle].posy == -vehicles[activeVehicle].aoY
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    }
                                }
                        }
                    }
                }
                if (key == "e") {
                    if (activeVehicle == 0) {
                        activeVehicle = 1;
                    } else {
                        activeVehicle = 0;
                    }
                }
                if (key == "c") {
                    for (var y = 0; y < blocks.length; y++) {
                        for (var x = 0; x < blocks[y].length; x++) {
                            if (blocks[y][x].willGrow) {
                                if (blocks[y][x].state + 1 < 6) {
                                    blocks[y][x].tillGrown -= 1;
                                    blocks[y][x].state += 1;
                                }
                            }
                        }
                    }
                }
            }

            function updateMap() {
                for (var y = 0; y <= height / spriteSize; y++) {
                    for (var x = 0; x <= width / spriteSize; x++) {
                        paintImage(matchingImage[blocks[y][x].state], spriteSize * x, spriteSize * y, 0);
                    }
                }
            }

            function paintImage(image, x, y, angle) {
                painter.save();
                painter.translate(x, y);
                painter.rotate(toRadian(180 + angle));
                painter.drawImage(image, -1 * (spriteSize / 2), -1 * (spriteSize / 2));
                painter.restore();
            }

            function toRadian(angle) {
                return (180 + angle) * (Math.PI / 180);
            }

            function clearScreen() {
                painter.clearRect(0, 0, width, height);
            }

            function findSlope(y2, y1, x2, x1) {
                return ((y2 - y1) / (x2 - x1)) * -1;
            }

            function drawCircle(sX, sY, hStretch, vStretch, rotation, r, g, b) {
                painter.beginPath();
                painter.strokeStyle = "rgb(" + r + "," + g + "," + b + ")";
                painter.ellipse(sX, sY, hStretch, vStretch, rotation, 0, 360);
                painter.stroke();
                painter.fill();
                painter.closePath();
            }

            function drawLine(sX, sY, eX, eY, r, g, b) {
                painter.beginPath();
                painter.strokeStyle = `rgb(${r},${g},${b})`;
                painter.moveTo(sX, sY);
                painter.lineTo(eX, eY);
                painter.closePath();
                painter.stroke();
            }

            function inteceptCircleLineSeg(radius, circleX, circleY, ax, ay, bx, by) {
                var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;
                v1 = {};
                v2 = {};
                v1.x = bx - ax;
                v1.y = by - ay;
                v2.x = ax - circleX;
                v2.y = ay - circleY;
                b = v1.x * v2.x + v1.y * v2.y;
                c = 2 * (v1.x * v1.x + v1.y * v1.y);
                b *= -2;
                d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - radius * radius));
                if (isNaN(d)) {
                    // no intercept
                    return [];
                }
                u1 = (b - d) / c; // these represent the unit distance of point one and two on the line
                u2 = (b + d) / c;
                retP1 = {}; // return points
                retP2 = {};
                ret = []; // return array
                if (u1 <= 1 && u1 >= 0) {
                    // add point if on the line segment
                    retP1.x = ax + v1.x * u1;
                    retP1.y = ay + v1.y * u1;
                    ret[0] = retP1;
                }
                if (u2 <= 1 && u2 >= 0) {
                    // second add point if on the line segment
                    retP2.x = ax + v1.x * u2;
                    retP2.y = ay + v1.y * u2;
                    ret[ret.length] = retP2;
                }
                return ret;
            }

            document.addEventListener(
                "keydown",
                (event) => {
                    var name = event.key;
                    input(name);
                },
                false
            );

            document.onmousemove = function (event) {
                pointerX = event.pageX;
                pointerY = event.pageY;
            };

            setup();
            setInterval(update, 1 / 30);
        </script>
    </body>
</html>
