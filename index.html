<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Farmunation</title>
        <link rel="icon" type="image/x-icon" href="/Icon.png" />
        <style>
            @import url("https://fonts.googleapis.com/css2?family=Barlow&family=IBM+Plex+Mono&display=swap");

            html {
                font-family: "Barlow", sans-serif;
            }

            .body {
                --bg: #f2f2f2;
                display: flex;
                height: 100vh;
                flex-direction: column;
                margin: 0;
                background-color: var(--bg);
            }

            .b {
                --lnk: #465e73;
                color: var(--lnk);
                font-weight: 800;
            }

            div {
                width: 55%;
                margin-left: auto;
                margin-right: auto;
            }

            ul {
                display: flex;
                margin: auto;
                margin-block-start: 1em;
                margin-block-end: 1em;
                margin-inline-start: 0px;
                margin-inline-end: 0px;
                flex-wrap: wrap;
                justify-content: space-between;
                padding: 0;
            }

            #main-renderer {
                font-family: "IBM Plex Mono";
                padding: 20px 0px;
                font-size: 30px;
                margin: auto;
                width: 90%;
                text-align: center;
                line-height: 1.15;
            }

            .sesame-seeds {
                --headers: #00010d;
                color: var(--headers);
                margin-bottom: 1;
            }

            .theme {
                --bc: #a8b5bf;
                border-style: hidden;
                background-color: var(--bc);
                border-radius: 5px;
                padding: 15px;
            }

            .theme:active {
                --hghltd: #728ca3;
                background-color: var(--hghltd);
            }

            .fluff {
                --text: #00010d;
                color: var(--text);
            }

            #footer {
                position: absolute;
                bottom: 0;
            }
            #bottom-bun {
                margin-top: auto;
            }
            canvas {
                background-color: whitesmoke;
                image-rendering: pixelated;
                image-rendering: crisp-edges;
                margin: auto;
                display: block;
                width: 100%;
                border-radius: 2%;
            }
        </style>
    </head>
    <body class="body">
        <div id="top-bun">
            <h1 class="sesame-seeds">Farmunation</h1>
            <p class="fluff">update description</p>
        </div>
        <div>
            <canvas id="main" width="512" height="512"></canvas>
        </div>
        <div id="bottom-bun">
            <footer>
                <ul>
                    <p class="fluff">Started By Ethan Huber On 11/5/22</p>
                    <a style="text-decoration: none" href="https://x.com"><p class="b">Website</p></a>
                    <a style="text-decoration: none" href="https://github.com/zushiEdu/Farmunation"><p class="b">Farmunation</p></a>
                    <a style="text-decoration: none" href="https://github.com/zushiEdu/"><p class="b">Github</p></a>
                </ul>
            </footer>
        </div>

        <script>
            function implement(posx, posy, rot, active, name, bF, aF, toolType, ax, ay, inventory) {
                this.posx = posx;
                this.posy = posy;
                this.rot = rot;
                this.active = active;
                this.name = name;
                this.bF = bF;
                this.aF = aF;
                this.toolType = toolType;
                this.ax = ax;
                this.ay = ay;
                this.inventory = inventory;
            }
            function tile(state, willGrow, tillGrown, yield, cropType) {
                this.state = state;
                this.willGrow = willGrow;
                this.tillGrown = tillGrown;
                this.yield = yield;
                this.cropType = cropType;
            }
            function vehicle(posx, posy, rotation, attachedImplement, implementAttached, fuel, name, aoX, aoY, inventory) {
                this.posx = posx;
                this.posy = posy;
                this.rotation = rotation;
                this.attachedImplement = attachedImplement;
                this.implementAttached = implementAttached;
                this.fuel = fuel;
                this.name = name;
                this.aoX = aoX;
                this.aoY = aoY;
                this.inventory = inventory;
            }
            function item(name, amount) {
                this.name = name;
                this.amount = amount;
            }

            const spriteSize = 16;
            const c = document.getElementById("main");
            const painter = c.getContext("2d", { alpha: false });
            //painter.scale(32 / spriteSize, 32 / spriteSize);
            painter.translate(8, 8);
            painter.imageSmoothingEnabled = false;

            const width = c.width;
            const height = c.height;
            const centerX = width / 2;
            const centerY = height / 2;

            var pointerX = 0;
            var pointerY = 0;

            var chunkX = 0;
            var chunkY = 0;

            const canvasSize = width / spriteSize;
            const mapSize = canvasSize * 8;
            const mapScale = 8;

            var implements = new Array();
            // TO = tool offset
            //                            X, Y, R,  On,    Name,        TOX,TOY, Matching Vehicle
            implements[0] = new implement(2, 2, 90, false, "Disc Harrow", 0, 1, "Tractor", 0, 0, null);
            implements[1] = new implement(2, 4, 90, false, "Planter", 1, 2, "Tractor", 0, 0, new item("Grain", 50));
            implements[2] = new implement(2, 10, 90, false, "Grain Header", 5, 6, "Harvester", 0, 0, null);
            implements[3] = new implement(2, 13, 90, false, "Disc Harrow", 0, 1, "Tractor", -1, 1, null);
            implements[4] = new implement(2, 16, 90, false, "Grain Trailer", 0, 1, "Tractor", 0, 0, new item("Grain", 0));

            var activeVehicle = 0;
            var vehicles = new Array();
            vehicles[0] = new vehicle(2, 6, 90, 0, false, 100, "Tractor", 1, 1, new item("Repair Kit", 1));
            vehicles[1] = new vehicle(2, 8, 90, null, false, 100, "Harvester", 0, 0, new item("Grain", 0));

            // Image Section
            var matchingImage = new Array();

            matchingImage[0] = new Image();
            matchingImage[0].src = `/${spriteSize}xSprites/Grass.png`;

            matchingImage[1] = new Image();
            matchingImage[1].src = `/${spriteSize}xSprites/Cultivated.png`;

            matchingImage[2] = new Image();
            matchingImage[2].src = `/${spriteSize}xSprites/PlantedStage1.png`;

            matchingImage[3] = new Image();
            matchingImage[3].src = `/${spriteSize}xSprites/PlantedStage3.png`;

            matchingImage[4] = new Image();
            matchingImage[4].src = `/${spriteSize}xSprites/PlantedStage5.png`;

            matchingImage[5] = new Image();
            matchingImage[5].src = `/${spriteSize}xSprites/PlantedStage6.png`;

            matchingImage[6] = new Image();
            matchingImage[6].src = `/${spriteSize}xSprites/Harvested.png`;

            var machines = new Array();

            fillMachineArray();

            machines[0].src = `/${spriteSize}xSprites/Tractor.png`;
            machines[1].src = `/${spriteSize}xSprites/Cultivator.png`;
            machines[2].src = `/${spriteSize}xSprites/Planter.png`;
            machines[3].src = `/${spriteSize}xSprites/Harvester.png`;
            machines[4].src = `/${spriteSize}xSprites/GrainHeader.png`;
            machines[5].src = `/${spriteSize}xSprites/LargeCultivator.png`;
            machines[6].src = `/${spriteSize}xSprites/GrainTrailer.png`;

            var blocks = [[new tile()]];

            function fillMachineArray() {
                for (var i = 0; i < 7; i++) {
                    machines[i] = new Image();
                }
            }

            function setup() {
                // create basic map
                for (var y = 0; y <= mapSize; y++) {
                    blocks[y] = [];
                    for (var x = 0; x <= mapSize; x++) {
                        blocks[y][x] = new tile(0, false, null, null);
                    }
                }
                setTimeout(renderMap, 1);
            }

            function update() {
                // rendering
                updateMap();

                //render all machines
                var osX = chunkX * spriteSize * canvasSize;
                var osY = chunkY * spriteSize * canvasSize;
                paintImage(machines[0], spriteSize * vehicles[0].posx - osX, spriteSize * vehicles[0].posy - osY, vehicles[0].rotation);
                paintImage(machines[1], spriteSize * implements[0].posx - osX, spriteSize * implements[0].posy - osY, implements[0].rot);
                paintImage(machines[2], spriteSize * implements[1].posx - osX, spriteSize * implements[1].posy - osY, implements[1].rot);
                paintImage(machines[3], spriteSize * vehicles[1].posx - osX, spriteSize * vehicles[1].posy - osY, vehicles[1].rotation);
                paintImage(machines[4], spriteSize * implements[2].posx - osX, spriteSize * implements[2].posy - osY, implements[2].rot);
                paintImage(
                    machines[5],
                    spriteSize * (implements[3].posx - implements[3].ax * Math.cos(toRadian(implements[3].rot))) - osX,
                    spriteSize * (implements[3].posy + implements[3].ay * Math.sin(toRadian(implements[3].rot))) - osY,
                    implements[3].rot
                );
                paintImage(machines[6], spriteSize * implements[4].posx - osX, spriteSize * implements[4].posy - osY, implements[4].rot);

                // ui
                roundedRect(0, 0, 512 - 16 - 100, 20, 5, 0, 0, 0);
                roundedRect(512 - 16 - 100 + 10, 0, 90, 20, 5, 0, 0, 0);
                var at;
                if (vehicles[activeVehicle].implementAttached) {
                    if (implements[vehicles[activeVehicle].attachedImplement].inventory != null) {
                        at =
                            ", " +
                            implements[vehicles[activeVehicle].attachedImplement].name +
                            ": " +
                            implements[vehicles[activeVehicle].attachedImplement].inventory.name +
                            ", " +
                            implements[vehicles[activeVehicle].attachedImplement].inventory.amount;
                    } else {
                        at = ", " + implements[vehicles[activeVehicle].attachedImplement].name;
                    }
                } else {
                    at = "";
                }
                drawText(
                    vehicles[activeVehicle].name + ": " + vehicles[activeVehicle].inventory.name + ", " + vehicles[activeVehicle].inventory.amount + at,
                    5,
                    15,
                    255,
                    255,
                    255
                );
                drawText(vehicles[activeVehicle].posx + ", " + vehicles[activeVehicle].posy, 512 - 16 - 80, 15, 255, 255, 255);

                // implement application
                if (vehicles[activeVehicle].implementAttached) {
                    if (implements[vehicles[activeVehicle].attachedImplement].active) {
                        var ax = implements[vehicles[activeVehicle].attachedImplement].ax;
                        var ay = implements[vehicles[activeVehicle].attachedImplement].ay;

                        if (
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 0 ||
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 6 ||
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 2 ||
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 1
                        ) {
                            // cultivate land
                            if (implements[vehicles[activeVehicle].attachedImplement].name == "Disc Harrow") {
                                blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx] =
                                    new tile(1, false, null, null, "Cultivated");
                                if (implements[vehicles[activeVehicle].attachedImplement].ax != 0) {
                                    blocks[
                                        implements[vehicles[activeVehicle].attachedImplement].posy +
                                            implements[3].ay * Math.round(Math.sin(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                    ][
                                        implements[vehicles[activeVehicle].attachedImplement].posx -
                                            implements[3].ax * Math.round(Math.cos(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                    ] = new tile(1, false, null, null, "Cultivated");
                                    blocks[
                                        implements[vehicles[activeVehicle].attachedImplement].posy -
                                            implements[3].ay * Math.round(Math.sin(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                    ][
                                        implements[vehicles[activeVehicle].attachedImplement].posx +
                                            implements[3].ax * Math.round(Math.cos(toRadian(implements[vehicles[activeVehicle].attachedImplement].rot)))
                                    ] = new tile(1, false, null, null, "Cultivated");
                                }
                            }
                        } else if (
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 2
                        ) {
                            // fertilize crop
                            if (implements[vehicles[activeVehicle].attachedImplement].name == "Sprayer") {
                                blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx] =
                                    new tile(
                                        2,
                                        true,
                                        blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                            implements[vehicles[activeVehicle].attachedImplement].posx
                                        ].yield + 0.25,
                                        blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                            implements[vehicles[activeVehicle].attachedImplement].posx
                                        ].cropType
                                    );
                            }
                        } else if (
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 5
                        ) {
                            if (implements[vehicles[activeVehicle].attachedImplement].name == "Grain Header") {
                                if (vehicles[activeVehicle].inventory.name == "Grain") {
                                    vehicles[activeVehicle].inventory.amount +=
                                        1 *
                                        blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                            implements[vehicles[activeVehicle].attachedImplement].posx
                                        ].yield;

                                    blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                        implements[vehicles[activeVehicle].attachedImplement].posx
                                    ] = new tile(6, false, null, null);
                                }
                            }
                            // harvest crop
                            // calculate yield and what to deposit based on crop type
                        }
                        if (
                            blocks[implements[vehicles[activeVehicle].attachedImplement].posy][implements[vehicles[activeVehicle].attachedImplement].posx]
                                .state == 1
                        ) {
                            // plant crop on land
                            if (implements[vehicles[activeVehicle].attachedImplement].name == "Planter") {
                                if (implements[vehicles[activeVehicle].attachedImplement].inventory.amount >= 1) {
                                    blocks[implements[vehicles[activeVehicle].attachedImplement].posy][
                                        implements[vehicles[activeVehicle].attachedImplement].posx
                                    ] = new tile(2, true, 5, 0.5, implements[vehicles[activeVehicle].attachedImplement].inventory.name);
                                    implements[vehicles[activeVehicle].attachedImplement].inventory.amount -= 1;
                                }
                            }
                        }
                    }
                }
            }

            function moveVehicle(f) {
                if (f) {
                    vehicles[activeVehicle].posy += Math.round(Math.cos(toRadian(vehicles[activeVehicle].rotation)));
                    vehicles[activeVehicle].posx -= Math.round(Math.sin(toRadian(vehicles[activeVehicle].rotation)));
                } else {
                    vehicles[activeVehicle].posy -= Math.round(Math.cos(toRadian(vehicles[activeVehicle].rotation)));
                    vehicles[activeVehicle].posx += Math.round(Math.sin(toRadian(vehicles[activeVehicle].rotation)));
                }
            }

            function moveImplement(f) {
                if (f) {
                    implements[vehicles[activeVehicle].attachedImplement].posx = vehicles[activeVehicle].posx;
                    implements[vehicles[activeVehicle].attachedImplement].posy = vehicles[activeVehicle].posy;
                    implements[vehicles[activeVehicle].attachedImplement].rot = vehicles[activeVehicle].rotation;
                } else {
                    implements[vehicles[activeVehicle].attachedImplement].posx += Math.round(Math.sin(toRadian(vehicles[activeVehicle].rotation)));
                    implements[vehicles[activeVehicle].attachedImplement].posy -= Math.round(Math.cos(toRadian(vehicles[activeVehicle].rotation)));
                    implements[vehicles[activeVehicle].attachedImplement].rot = vehicles[activeVehicle].rotation;
                }
            }

            function input(key) {
                if (key == "w") {
                    if (vehicles[activeVehicle].aoX == 0) {
                        var posChangeY = vehicles[activeVehicle].posy + Math.round(Math.cos(toRadian(vehicles[activeVehicle].rotation)));
                        var posChangeX = vehicles[activeVehicle].posx - Math.round(Math.sin(toRadian(vehicles[activeVehicle].rotation)));
                        if (posChangeY >= 0 && posChangeY < canvasSize * mapScale) {
                            if (posChangeX >= 0 && posChangeX < canvasSize * mapScale) {
                                moveVehicle(true);
                            }
                        }
                        if (vehicles[activeVehicle].posx == (chunkX + 1) * canvasSize) {
                            chunkX += 1;
                        }
                    }
                    if (vehicles[activeVehicle].implementAttached) {
                        moveImplement(true);
                    }

                    if (vehicles[activeVehicle].aoX != 0) {
                        var posChangeY = vehicles[activeVehicle].posy + Math.round(Math.cos(toRadian(vehicles[activeVehicle].rotation)));
                        var posChangeX = vehicles[activeVehicle].posx - Math.round(Math.sin(toRadian(vehicles[activeVehicle].rotation)));
                        if (posChangeY >= 0 && posChangeY < canvasSize * mapScale) {
                            if (posChangeX >= 0 && posChangeX < canvasSize * mapScale) {
                                moveVehicle(true);
                            }
                        }
                        if (vehicles[activeVehicle].posx == (chunkX + 1) * canvasSize) {
                            chunkX += 1;
                        }
                        if (vehicles[activeVehicle].posy == (chunkY + 1) * canvasSize) {
                            chunkY += 1;
                        }
                    }
                }
                if (key == "s") {
                    moveVehicle(false);

                    if (vehicles[activeVehicle].implementAttached) {
                        moveImplement(false);
                    }
                }
                if (key == "d") {
                    if (vehicles[activeVehicle].aoX == 0) {
                        if (vehicles[activeVehicle].rotation + 45 == 225) {
                            vehicles[activeVehicle].rotation = -135;
                        } else {
                            vehicles[activeVehicle].rotation += 45;
                        }
                    }
                    if (vehicles[activeVehicle].implementAttached) {
                        implements[vehicles[activeVehicle].attachedImplement].rot = vehicles[activeVehicle].rotation;
                    }
                    if (vehicles[activeVehicle].aoX != 0) {
                        if (vehicles[activeVehicle].rotation + 45 == 225) {
                            vehicles[activeVehicle].rotation = -135;
                        } else {
                            vehicles[activeVehicle].rotation += 45;
                        }
                    }
                }
                if (key == "a") {
                    if (vehicles[activeVehicle].aoX == 0) {
                        if (vehicles[activeVehicle].rotation - 45 == -225) {
                            vehicles[activeVehicle].rotation = 135;
                        } else {
                            if (vehicles[activeVehicle].rotation - 45 == -180) {
                                vehicles[activeVehicle].rotation = 180;
                            } else {
                                vehicles[activeVehicle].rotation -= 45;
                            }
                        }
                    }
                    if (vehicles[activeVehicle].implementAttached) {
                        implements[vehicles[activeVehicle].attachedImplement].rot = vehicles[activeVehicle].rotation;
                    }
                    if (vehicles[activeVehicle].aoX != 0) {
                        if (vehicles[activeVehicle].rotation - 45 == -225) {
                            vehicles[activeVehicle].rotation = 135;
                        } else {
                            if (vehicles[activeVehicle].rotation - 45 == -180) {
                                vehicles[activeVehicle].rotation = 180;
                            } else {
                                vehicles[activeVehicle].rotation -= 45;
                            }
                        }
                    }
                }
                if (key == "v") {
                    if (vehicles[activeVehicle].implementAttached) {
                        if (implements[vehicles[activeVehicle].attachedImplement].active) {
                            implements[vehicles[activeVehicle].attachedImplement].active = false;
                        } else {
                            implements[vehicles[activeVehicle].attachedImplement].active = true;
                        }
                    }
                }
                if (key == "q") {
                    if (vehicles[activeVehicle].implementAttached) {
                        vehicles[activeVehicle].implementAttached = false;
                    } else {
                        for (var i = 0; i < implements.length; i++) {
                            if (implements[i].toolType == vehicles[activeVehicle].name) {
                                if (implements[i].posy == vehicles[activeVehicle].posy) {
                                    if (
                                        implements[i].rot == 90 &&
                                        vehicles[activeVehicle].rotation == 90 &&
                                        implements[i].posx - vehicles[activeVehicle].posx == -vehicles[activeVehicle].aoX
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    } else if (
                                        implements[i].rot == -90 &&
                                        vehicles[activeVehicle].rotation == -90 &&
                                        implements[i].posx - vehicles[activeVehicle].posx == vehicles[activeVehicle].aoX
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    }
                                } else if (implements[i].posx == vehicles[activeVehicle].posx) {
                                    if (
                                        implements[i].rot == 0 &&
                                        vehicles[activeVehicle].rotation == 0 &&
                                        implements[i].posy - vehicles[activeVehicle].posy == vehicles[activeVehicle].aoY
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    } else if (
                                        implements[i].rot == 180 &&
                                        vehicles[activeVehicle].rotation == 180 &&
                                        implements[i].posy - vehicles[activeVehicle].posy == -vehicles[activeVehicle].aoY
                                    ) {
                                        vehicles[activeVehicle].implementAttached = true;
                                        vehicles[activeVehicle].attachedImplement = i;
                                    }
                                } else if (
                                    distanceBetweenPoints(implements[i].posx, implements[i].posy, vehicles[activeVehicle].posx, vehicles[activeVehicle].posy) <=
                                        1.5 ||
                                    distanceBetweenPoints(implements[i].posx, implements[i].posy, vehicles[activeVehicle].posx, vehicles[activeVehicle].posy) <=
                                        -1.5
                                ) {
                                    vehicles[activeVehicle].implementAttached = true;
                                    vehicles[activeVehicle].attachedImplement = i;
                                }
                            }
                        }
                    }
                }
                if (key == "e") {
                    if (activeVehicle == 0) {
                        activeVehicle = 1;
                    } else {
                        activeVehicle = 0;
                    }
                }
                if (key == "c") {
                    for (var y = 0; y < blocks.length; y++) {
                        for (var x = 0; x < blocks[y].length; x++) {
                            if (blocks[y][x].willGrow) {
                                if (blocks[y][x].state + 1 < 6) {
                                    blocks[y][x].tillGrown -= 1;
                                    blocks[y][x].state += 1;
                                }
                            }
                        }
                    }
                }
                if (key == "r") {
                    if (vehicles[activeVehicle].name == "Harvester") {
                        if (implements[4].rot == vehicles[activeVehicle].rotation) {
                            // same rotation
                            console.log(vehicles[activeVehicle].posy - implements[4].posy);
                            console.log(vehicles[activeVehicle].posx - implements[4].posx);
                            if (implements[4].posy - vehicles[activeVehicle].posy == 1 || implements[4].posy - vehicles[activeVehicle].posy == -1) {
                                if (implements[4].posx - vehicles[activeVehicle].posx == 0) {
                                    if (vehicles[activeVehicle].rotation == 90 || vehicles[activeVehicle].rotation == -90) {
                                        console.log(implements[4].inventory.amount + vehicles[activeVehicle].inventory.amount);
                                        implements[4].inventory.amount += vehicles[activeVehicle].inventory.amount;
                                        vehicles[activeVehicle].inventory.amount = 0;
                                    }
                                }
                            } else if (implements[4].posx - vehicles[activeVehicle].posx == 1 || implements[4].posx - vehicles[activeVehicle].posx == -1) {
                                if (implements[4].posy - vehicles[activeVehicle].posy == 0) {
                                    if (vehicles[activeVehicle].rotation == 0 || vehicles[activeVehicle].rotation == 180) {
                                        console.log(implements[4].inventory.amount + vehicles[activeVehicle].inventory.amount);
                                        implements[4].inventory.amount += vehicles[activeVehicle].inventory.amount;
                                        vehicles[activeVehicle].inventory.amount = 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function distanceBetweenPoints(x1, y1, x2, y2) {
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            }

            function renderMap() {
                for (var y = chunkY * canvasSize; y < (chunkY + 1) * canvasSize; y++) {
                    for (var x = chunkX * canvasSize; x < (chunkX + 1) * canvasSize; x++) {
                        paintImage(
                            matchingImage[blocks[y][x].state],
                            x * spriteSize - chunkX * spriteSize * canvasSize,
                            y * spriteSize - chunkY * spriteSize * canvasSize,
                            0
                        );
                    }
                }
            }

            function updateMap() {
                for (var i = 0; i < implements.length; i++) {
                    for (var y = -2; y <= 2; y++) {
                        for (var x = -2; x <= 2; x++) {
                            if (
                                implements[i].posx + x >= 0 &&
                                implements[i].posx + x <= mapSize &&
                                implements[i].posy + y >= 0 &&
                                implements[i].posy + y <= mapSize
                            ) {
                                paintImage(
                                    matchingImage[blocks[implements[i].posy + y][implements[i].posx + x].state],
                                    (implements[i].posx + x) * spriteSize - chunkX * spriteSize * canvasSize,
                                    (implements[i].posy + y) * spriteSize - chunkY * spriteSize * canvasSize,
                                    0
                                );
                            }
                        }
                    }
                }
                for (var i = 0; i < vehicles.length; i++) {
                    for (var y = -2; y <= 2; y++) {
                        for (var x = -2; x <= 2; x++) {
                            if (vehicles[i].posx + x >= 0 && vehicles[i].posx + x <= mapSize && vehicles[i].posy + y >= 0 && vehicles[i].posy + y <= mapSize) {
                                paintImage(
                                    matchingImage[blocks[vehicles[i].posy + y][vehicles[i].posx + x].state],
                                    (vehicles[i].posx + x) * spriteSize - chunkX * spriteSize * canvasSize,
                                    (vehicles[i].posy + y) * spriteSize - chunkY * spriteSize * canvasSize,
                                    0
                                );
                            }
                        }
                    }
                }
            }

            function paintImage(image, x, y, angle) {
                painter.save();
                painter.translate(x, y);
                painter.rotate(toRadian(180 + angle));
                painter.drawImage(image, -1 * (spriteSize / 2), -1 * (spriteSize / 2));
                painter.restore();
            }

            function toRadian(angle) {
                return (180 + angle) * (Math.PI / 180);
            }

            function clearScreen() {
                painter.clearRect(0, 0, width, height);
            }

            function findSlope(y2, y1, x2, x1) {
                return ((y2 - y1) / (x2 - x1)) * -1;
            }

            function drawRect(x1, y1, x2, y2, r, g, b) {
                painter.strokeStyle = "rgb(" + r + "," + g + "," + b + ")";
                painter.beginPath();
                painter.fillRect(x1, y1, x2, y2);
                painter.closePath();
            }

            function roundedRect(x, y, width, height, radius, r, g, b) {
                painter.beginPath();
                painter.moveTo(x, y + radius);
                painter.arcTo(x, y + height, x + radius, y + height, radius);
                painter.arcTo(x + width, y + height, x + width, y + height - radius, radius);
                painter.arcTo(x + width, y, x + width - radius, y, radius);
                painter.arcTo(x, y, x, y + radius, radius);
                painter.strokeStyle = "rgb(" + r + "," + g + "," + b + ")";
                painter.stroke();
                painter.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
                painter.fill();
                painter.closePath();
            }

            function drawText(text, x, y, r, g, b) {
                painter.beginPath();
                painter.font = "15px Arial";
                painter.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
                painter.fillText(text, x, y + 1);
                painter.closePath();
            }

            function drawCircle(sX, sY, hStretch, vStretch, rotation, r, g, b) {
                painter.beginPath();
                painter.strokeStyle = "rgb(" + r + "," + g + "," + b + ")";
                painter.ellipse(sX, sY, hStretch, vStretch, rotation, 0, 360);
                painter.stroke();
                painter.fill();
                painter.closePath();
            }

            function drawLine(sX, sY, eX, eY, r, g, b) {
                painter.beginPath();
                painter.strokeStyle = `rgb(${r},${g},${b})`;
                painter.moveTo(sX, sY);
                painter.lineTo(eX, eY);
                painter.closePath();
                painter.stroke();
            }

            function inteceptCircleLineSeg(radius, circleX, circleY, ax, ay, bx, by) {
                var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;
                v1 = {};
                v2 = {};
                v1.x = bx - ax;
                v1.y = by - ay;
                v2.x = ax - circleX;
                v2.y = ay - circleY;
                b = v1.x * v2.x + v1.y * v2.y;
                c = 2 * (v1.x * v1.x + v1.y * v1.y);
                b *= -2;
                d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - radius * radius));
                if (isNaN(d)) {
                    // no intercept
                    return [];
                }
                u1 = (b - d) / c; // these represent the unit distance of point one and two on the line
                u2 = (b + d) / c;
                retP1 = {}; // return points
                retP2 = {};
                ret = []; // return array
                if (u1 <= 1 && u1 >= 0) {
                    // add point if on the line segment
                    retP1.x = ax + v1.x * u1;
                    retP1.y = ay + v1.y * u1;
                    ret[0] = retP1;
                }
                if (u2 <= 1 && u2 >= 0) {
                    // second add point if on the line segment
                    retP2.x = ax + v1.x * u2;
                    retP2.y = ay + v1.y * u2;
                    ret[ret.length] = retP2;
                }
                return ret;
            }

            document.addEventListener(
                "keydown",
                (event) => {
                    var name = event.key;
                    input(name);
                },
                false
            );

            document.onmousemove = function (event) {
                pointerX = event.pageX;
                pointerY = event.pageY;
            };

            setup();
            setInterval(update, 1 / 30);
        </script>
    </body>
</html>
